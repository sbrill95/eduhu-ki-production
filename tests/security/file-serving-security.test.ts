/**
 * Security test suite for file serving functionality
 * Tests path traversal, authentication, authorization, and access control
 */

import { createMocks } from 'node-mocks-http'
import { GET, HEAD } from '@/app/api/files/[...path]/route'
import { NextRequest } from 'next/server'
import { validateFileForStorage } from '@/lib/file-storage'

// Mock dependencies
jest.mock('@/lib/instant', () => ({
  db: {
    query: jest.fn(),
    transact: jest.fn()
  },
  FILE_UPLOAD_CONFIG: {
    MAX_FILE_SIZE_MB: 10,
    ALLOWED_TYPES: ['text/plain', 'image/*', 'application/pdf']
  }
}))

jest.mock('@/lib/database', () => ({
  validateSessionAccess: jest.fn()
}))

jest.mock('fs/promises')
jest.mock('fs', () => ({
  existsSync: jest.fn()
}))

const mockFs = require('fs/promises')
const mockExistsSync = require('fs').existsSync

describe('File Serving Security Tests', () => {
  const TEST_TEACHER_ID = 'teacher_123'
  const TEST_SESSION_ID = 'session_456'
  const MALICIOUS_TEACHER_ID = 'malicious_teacher'

  beforeEach(() => {
    jest.clearAllMocks()

    const mockDb = require('@/lib/instant').db
    mockDb.query.mockResolvedValue({ file_uploads: [] })
    mockDb.transact.mockResolvedValue({})

    const mockValidateSessionAccess = require('@/lib/database').validateSessionAccess
    mockValidateSessionAccess.mockResolvedValue(true)
  })

  describe('Path Traversal Prevention', () => {
    const pathTraversalTests = [
      {
        name: 'should block simple path traversal with ../../../',
        path: ['..', '..', '..', 'etc', 'passwd'],
        expectedStatus: 400,
        expectedError: 'Invalid file path'
      },
      {
        name: 'should block URL encoded path traversal',
        path: ['%2e%2e', '%2f%2e%2e', '%2f%2e%2e', 'etc', 'passwd'],
        expectedStatus: 400,
        expectedError: 'Invalid file path'
      },
      {
        name: 'should block mixed case path traversal',
        path: ['..%2F', '..%5C', 'windows', 'system32'],
        expectedStatus: 400,
        expectedError: 'Invalid file path'
      },
      {
        name: 'should block tilde home directory access',
        path: ['~', 'user', '.ssh', 'id_rsa'],
        expectedStatus: 400,
        expectedError: 'Invalid file path'
      },
      {
        name: 'should block backslash path traversal (Windows)',
        path: ['..\\\\..\\\\..\\\\windows\\\\system32\\\\config\\\\sam'],
        expectedStatus: 400,
        expectedError: 'Invalid file path'
      },
      {
        name: 'should block absolute path access',
        path: ['/', 'etc', 'passwd'],
        // This might pass path validation but should fail file access\n        expectedStatus: 404\n      },\n      {\n        name: 'should block Windows drive access',\n        path: ['C:', 'windows', 'system32'],\n        expectedStatus: 404\n      },\n      {\n        name: 'should block null byte injection',\n        path: ['file.txt\\x00.exe'],\n        expectedStatus: 400,\n        expectedError: 'Invalid file path'\n      }\n    ]\n\n    pathTraversalTests.forEach(test => {\n      it(test.name, async () => {\n        const pathStr = test.path.join('/')\n        const request = new NextRequest(`http://localhost:3000/api/files/${pathStr}`)\n\n        const response = await GET(request, { params: { path: test.path } })\n\n        expect(response.status).toBe(test.expectedStatus)\n\n        if (test.expectedError && response.status >= 400) {\n          const body = await response.json()\n          expect(body.error).toBe(test.expectedError)\n        }\n      })\n    })\n\n    it('should sanitize and normalize legitimate paths', async () => {\n      mockExistsSync.mockReturnValue(true)\n      mockFs.stat.mockResolvedValue({\n        size: 100,\n        mtime: new Date(),\n        birthtime: new Date(),\n        isFile: () => true\n      })\n      mockFs.readFile.mockResolvedValue(Buffer.from('safe content'))\n\n      // Test legitimate path variations\n      const legitimatePaths = [\n        ['2024', '01', 'document.pdf'],\n        ['2024', '01', 'subfolder', 'image.jpg'],\n        ['uploads', '2024', '01', 'file.txt']\n      ]\n\n      for (const path of legitimatePaths) {\n        const pathStr = path.join('/')\n        const request = new NextRequest(`http://localhost:3000/api/files/${pathStr}`)\n\n        const response = await GET(request, { params: { path } })\n\n        expect(response.status).toBe(200)\n      }\n    })\n  })\n\n  describe('Authentication and Authorization', () => {\n    beforeEach(() => {\n      mockExistsSync.mockReturnValue(true)\n      mockFs.stat.mockResolvedValue({\n        size: 200,\n        mtime: new Date(),\n        birthtime: new Date(),\n        isFile: () => true\n      })\n      mockFs.readFile.mockResolvedValue(Buffer.from('protected content'))\n    })\n\n    it('should allow access without authentication for public files', async () => {\n      const request = new NextRequest('http://localhost:3000/api/files/2024/01/public.txt')\n\n      const response = await GET(request, { params: { path: ['2024', '01', 'public.txt'] } })\n\n      expect(response.status).toBe(200)\n    })\n\n    it('should validate teacher ID when provided', async () => {\n      // Mock file owned by specific teacher\n      const mockDb = require('@/lib/instant').db\n      mockDb.query.mockResolvedValue({\n        file_uploads: [{\n          id: 'file123',\n          filename: 'protected.txt',\n          teacher_id: TEST_TEACHER_ID,\n          file_path: '2024/01/protected.txt'\n        }]\n      })\n\n      // Test access with correct teacher ID\n      const request = new NextRequest(\n        `http://localhost:3000/api/files/2024/01/protected.txt?teacherId=${TEST_TEACHER_ID}`\n      )\n\n      const response = await GET(request, { params: { path: ['2024', '01', 'protected.txt'] } })\n\n      expect(response.status).toBe(200)\n    })\n\n    it('should deny access to files owned by different teacher', async () => {\n      const mockDb = require('@/lib/instant').db\n      mockDb.query.mockResolvedValue({\n        file_uploads: [{\n          id: 'file123',\n          filename: 'private.txt',\n          teacher_id: 'different_teacher',\n          file_path: '2024/01/private.txt'\n        }]\n      })\n\n      const request = new NextRequest(\n        `http://localhost:3000/api/files/2024/01/private.txt?teacherId=${MALICIOUS_TEACHER_ID}`\n      )\n\n      const response = await GET(request, { params: { path: ['2024', '01', 'private.txt'] } })\n\n      expect(response.status).toBe(403)\n\n      const body = await response.json()\n      expect(body.error).toBe('File access denied')\n    })\n\n    it('should validate session access when sessionId provided', async () => {\n      const mockValidateSessionAccess = require('@/lib/database').validateSessionAccess\n      mockValidateSessionAccess.mockResolvedValue(true)\n\n      const request = new NextRequest(\n        `http://localhost:3000/api/files/2024/01/session-file.txt?teacherId=${TEST_TEACHER_ID}&sessionId=${TEST_SESSION_ID}`\n      )\n\n      const response = await GET(request, { params: { path: ['2024', '01', 'session-file.txt'] } })\n\n      expect(response.status).toBe(200)\n      expect(mockValidateSessionAccess).toHaveBeenCalledWith(TEST_SESSION_ID, TEST_TEACHER_ID)\n    })\n\n    it('should deny access for invalid session', async () => {\n      const mockValidateSessionAccess = require('@/lib/database').validateSessionAccess\n      mockValidateSessionAccess.mockResolvedValue(false)\n\n      const request = new NextRequest(\n        `http://localhost:3000/api/files/2024/01/session-file.txt?teacherId=${TEST_TEACHER_ID}&sessionId=invalid_session`\n      )\n\n      const response = await GET(request, { params: { path: ['2024', '01', 'session-file.txt'] } })\n\n      expect(response.status).toBe(403)\n\n      const body = await response.json()\n      expect(body.error).toBe('Unauthorized access to session')\n    })\n\n    it('should prevent session hijacking attempts', async () => {\n      const mockValidateSessionAccess = require('@/lib/database').validateSessionAccess\n      mockValidateSessionAccess.mockImplementation((sessionId, teacherId) => {\n        // Simulate session belonging to different teacher\n        return sessionId === 'hijacked_session' && teacherId !== 'original_teacher'\n          ? false\n          : true\n      })\n\n      const request = new NextRequest(\n        `http://localhost:3000/api/files/2024/01/sensitive.txt?teacherId=${MALICIOUS_TEACHER_ID}&sessionId=hijacked_session`\n      )\n\n      const response = await GET(request, { params: { path: ['2024', '01', 'sensitive.txt'] } })\n\n      expect(response.status).toBe(403)\n      expect(mockValidateSessionAccess).toHaveBeenCalledWith('hijacked_session', MALICIOUS_TEACHER_ID)\n    })\n  })\n\n  describe('Input Validation and Sanitization', () => {\n    it('should reject malformed teacher IDs', async () => {\n      const malformedIds = [\n        '../../../etc/passwd',\n        'teacher\\x00admin',\n        'teacher<script>alert(1)</script>',\n        'teacher\\'; DROP TABLE users; --',\n        'teacher\\x00\\x01\\x02',\n        'a'.repeat(1000) // Very long ID\n      ]\n\n      for (const malformedId of malformedIds) {\n        const encodedId = encodeURIComponent(malformedId)\n        const request = new NextRequest(\n          `http://localhost:3000/api/files/2024/01/test.txt?teacherId=${encodedId}`\n        )\n\n        // The API should handle malformed IDs gracefully\n        // This test ensures no crashes or security bypasses\n        const response = await GET(request, { params: { path: ['2024', '01', 'test.txt'] } })\n\n        expect(response.status).toBeLessThan(500) // Should not cause server error\n      }\n    })\n\n    it('should reject malformed session IDs', async () => {\n      const malformedSessions = [\n        '../../../admin',\n        'session\\x00',\n        'session<>',\n        '\\'; DROP TABLE sessions; --',\n        'a'.repeat(1000)\n      ]\n\n      for (const malformedSession of malformedSessions) {\n        const encodedSession = encodeURIComponent(malformedSession)\n        const request = new NextRequest(\n          `http://localhost:3000/api/files/2024/01/test.txt?teacherId=${TEST_TEACHER_ID}&sessionId=${encodedSession}`\n        )\n\n        const response = await GET(request, { params: { path: ['2024', '01', 'test.txt'] } })\n\n        expect(response.status).toBeLessThan(500)\n      }\n    })\n\n    it('should handle extremely long file paths', async () => {\n      const longPath = 'a'.repeat(1000)\n      const request = new NextRequest(`http://localhost:3000/api/files/${longPath}`)\n\n      const response = await GET(request, { params: { path: [longPath] } })\n\n      expect(response.status).toBe(404) // Should not crash, just return not found\n    })\n\n    it('should handle special characters in filenames', async () => {\n      const specialCharFiles = [\n        'file with spaces.txt',\n        'file-with-dashes.txt',\n        'file_with_underscores.txt',\n        'file.with.dots.txt',\n        'file(with)parentheses.txt'\n      ]\n\n      mockExistsSync.mockReturnValue(true)\n      mockFs.stat.mockResolvedValue({\n        size: 50,\n        mtime: new Date(),\n        birthtime: new Date(),\n        isFile: () => true\n      })\n      mockFs.readFile.mockResolvedValue(Buffer.from('content'))\n\n      for (const filename of specialCharFiles) {\n        const encodedFilename = encodeURIComponent(filename)\n        const request = new NextRequest(`http://localhost:3000/api/files/2024/01/${encodedFilename}`)\n\n        const response = await GET(request, { params: { path: ['2024', '01', filename] } })\n\n        expect(response.status).toBe(200)\n      }\n    })\n  })\n\n  describe('File Upload Validation Security', () => {\n    it('should reject dangerous file extensions', () => {\n      const dangerousFiles = [\n        new File(['exe content'], 'malware.exe', { type: 'application/octet-stream' }),\n        new File(['bat content'], 'script.bat', { type: 'text/plain' }),\n        new File(['js content'], 'malicious.js', { type: 'text/javascript' }),\n        new File(['vbs content'], 'virus.vbs', { type: 'text/plain' }),\n        new File(['scr content'], 'screensaver.scr', { type: 'application/octet-stream' }),\n        new File(['com content'], 'program.com', { type: 'application/octet-stream' }),\n        new File(['jar content'], 'trojan.jar', { type: 'application/java-archive' })\n      ]\n\n      dangerousFiles.forEach(file => {\n        const result = validateFileForStorage(file)\n        expect(result.isValid).toBe(false)\n        expect(result.errors).toContain(\n          expect.stringContaining('is not allowed for security reasons')\n        )\n      })\n    })\n\n    it('should validate file size limits', () => {\n      // Create oversized file (> 10MB mock limit)\n      const oversizedContent = 'x'.repeat(11 * 1024 * 1024)\n      const oversizedFile = new File([oversizedContent], 'large.txt', { type: 'text/plain' })\n\n      const result = validateFileForStorage(oversizedFile)\n\n      expect(result.isValid).toBe(false)\n      expect(result.errors).toContain(\n        expect.stringContaining('File size exceeds maximum')\n      )\n    })\n\n    it('should validate MIME types against whitelist', () => {\n      const disallowedFile = new File(['content'], 'script.js', { type: 'application/javascript' })\n\n      const result = validateFileForStorage(disallowedFile)\n\n      expect(result.isValid).toBe(false)\n      expect(result.errors).toContain(\n        expect.stringContaining('File type application/javascript is not allowed')\n      )\n    })\n\n    it('should reject files with null bytes in filename', () => {\n      const nullByteFile = new File(['content'], 'file\\x00.txt.exe', { type: 'text/plain' })\n\n      const result = validateFileForStorage(nullByteFile)\n\n      // Should be rejected due to dangerous extension\n      expect(result.isValid).toBe(false)\n    })\n  })\n\n  describe('Response Header Security', () => {\n    beforeEach(() => {\n      mockExistsSync.mockReturnValue(true)\n      mockFs.stat.mockResolvedValue({\n        size: 100,\n        mtime: new Date(),\n        birthtime: new Date(),\n        isFile: () => true\n      })\n      mockFs.readFile.mockResolvedValue(Buffer.from('test content'))\n    })\n\n    it('should include security headers in all responses', async () => {\n      const request = new NextRequest('http://localhost:3000/api/files/2024/01/test.txt')\n\n      const response = await GET(request, { params: { path: ['2024', '01', 'test.txt'] } })\n\n      expect(response.status).toBe(200)\n\n      // Verify security headers\n      expect(response.headers.get('x-content-type-options')).toBe('nosniff')\n      expect(response.headers.get('x-frame-options')).toBe('DENY')\n    })\n\n    it('should not expose internal file paths in error messages', async () => {\n      mockFs.stat.mockRejectedValue(new Error('ENOENT: no such file or directory, stat \\'/internal/path/file.txt\\''))\n\n      const request = new NextRequest('http://localhost:3000/api/files/2024/01/missing.txt')\n\n      const response = await GET(request, { params: { path: ['2024', '01', 'missing.txt'] } })\n\n      expect(response.status).toBe(404)\n\n      const body = await response.json()\n      expect(body.error).toBe('File not found')\n      expect(body.error).not.toContain('/internal/path/')\n    })\n\n    it('should not expose database error details', async () => {\n      const mockDb = require('@/lib/instant').db\n      mockDb.query.mockRejectedValue(new Error('Connection failed: ECONNREFUSED localhost:5432'))\n\n      const request = new NextRequest('http://localhost:3000/api/files/2024/01/test.txt')\n\n      const response = await GET(request, { params: { path: ['2024', '01', 'test.txt'] } })\n\n      // Should still serve file if database is down\n      expect(response.status).toBe(200)\n\n      // Check that database errors aren't exposed\n      expect(response.headers.get('x-error-details')).toBeNull()\n    })\n\n    it('should set appropriate content disposition for downloads', async () => {\n      // Test that potentially dangerous files are forced to download\n      const request = new NextRequest('http://localhost:3000/api/files/2024/01/document.docx')\n\n      const response = await GET(request, { params: { path: ['2024', '01', 'document.docx'] } })\n\n      expect(response.status).toBe(200)\n      expect(response.headers.get('content-disposition')).toBe('attachment; filename=\"document.docx\"')\n    })\n\n    it('should prevent content type sniffing attacks', async () => {\n      // Test files that could be misinterpreted by browsers\n      const testFiles = [\n        'suspicious.txt', // Could contain HTML\n        'data.csv', // Could contain scripts\n        'config.json' // Could be misinterpreted\n      ]\n\n      for (const filename of testFiles) {\n        const request = new NextRequest(`http://localhost:3000/api/files/2024/01/${filename}`)\n\n        const response = await GET(request, { params: { path: ['2024', '01', filename] } })\n\n        expect(response.status).toBe(200)\n        expect(response.headers.get('x-content-type-options')).toBe('nosniff')\n      }\n    })\n  })\n\n  describe('Rate Limiting and DoS Protection', () => {\n    it('should handle concurrent requests gracefully', async () => {\n      mockExistsSync.mockReturnValue(true)\n      mockFs.stat.mockResolvedValue({\n        size: 1000,\n        mtime: new Date(),\n        birthtime: new Date(),\n        isFile: () => true\n      })\n      mockFs.readFile.mockResolvedValue(Buffer.from('concurrent test content'))\n\n      // Simulate 10 concurrent requests\n      const requests = Array.from({ length: 10 }, (_, i) => {\n        const request = new NextRequest(`http://localhost:3000/api/files/2024/01/test${i}.txt`)\n        return GET(request, { params: { path: ['2024', '01', `test${i}.txt`] } })\n      })\n\n      const responses = await Promise.all(requests)\n\n      // All requests should succeed\n      responses.forEach(response => {\n        expect(response.status).toBe(200)\n      })\n    })\n\n    it('should handle malformed requests without crashing', async () => {\n      const malformedRequests = [\n        // Missing path segments\n        { path: [], expectedStatus: 400 },\n        // Extremely nested paths\n        { path: Array(100).fill('deep'), expectedStatus: 404 },\n        // Mixed valid/invalid segments\n        { path: ['2024', '..', 'file.txt'], expectedStatus: 400 }\n      ]\n\n      for (const testCase of malformedRequests) {\n        const pathStr = testCase.path.join('/')\n        const request = new NextRequest(`http://localhost:3000/api/files/${pathStr}`)\n\n        const response = await GET(request, { params: { path: testCase.path } })\n\n        expect(response.status).toBe(testCase.expectedStatus)\n      }\n    })\n  })\n\n  describe('Information Disclosure Prevention', () => {\n    it('should not reveal file existence through timing attacks', async () => {\n      // Mock different response times for existing vs non-existing files\n      let callCount = 0\n      mockFs.stat.mockImplementation(() => {\n        callCount++\n        if (callCount === 1) {\n          // First call - file exists (fast response)\n          return Promise.resolve({\n            size: 100,\n            mtime: new Date(),\n            birthtime: new Date(),\n            isFile: () => true\n          })\n        } else {\n          // Second call - file doesn't exist (should not be much slower)\n          return Promise.reject(new Error('ENOENT'))\n        }\n      })\n\n      const start1 = Date.now()\n      const request1 = new NextRequest('http://localhost:3000/api/files/2024/01/exists.txt')\n      await GET(request1, { params: { path: ['2024', '01', 'exists.txt'] } })\n      const time1 = Date.now() - start1\n\n      const start2 = Date.now()\n      const request2 = new NextRequest('http://localhost:3000/api/files/2024/01/missing.txt')\n      await GET(request2, { params: { path: ['2024', '01', 'missing.txt'] } })\n      const time2 = Date.now() - start2\n\n      // Response times should not differ significantly\n      const timeDiff = Math.abs(time1 - time2)\n      expect(timeDiff).toBeLessThan(1000) // Allow some variance but not too much\n    })\n\n    it('should not expose internal server structure in headers', async () => {\n      mockExistsSync.mockReturnValue(true)\n      mockFs.stat.mockResolvedValue({\n        size: 100,\n        mtime: new Date(),\n        birthtime: new Date(),\n        isFile: () => true\n      })\n      mockFs.readFile.mockResolvedValue(Buffer.from('content'))\n\n      const request = new NextRequest('http://localhost:3000/api/files/2024/01/test.txt')\n      const response = await GET(request, { params: { path: ['2024', '01', 'test.txt'] } })\n\n      expect(response.status).toBe(200)\n\n      // Check that no sensitive headers are exposed\n      expect(response.headers.get('server')).toBeNull()\n      expect(response.headers.get('x-powered-by')).toBeNull()\n      expect(response.headers.get('x-full-path')).toBeNull()\n    })\n  })\n})