/**
 * Analytics logging validation tests for file serving functionality
 * Tests that proper analytics are logged for various file operations
 */

import { createMocks } from 'node-mocks-http'\nimport { GET, HEAD } from '@/app/api/files/[...path]/route'\nimport { NextRequest } from 'next/server'\nimport {\n  setupCompleteTestEnvironment,\n  generateTestData,\n  createTestAssertions,\n  TEST_CONFIG\n} from '../utils/test-environment'\n\ndescribe('Analytics Validation Tests', () => {\n  const testEnv = setupCompleteTestEnvironment()\n  const testData = generateTestData()\n  const assertions = createTestAssertions()\n\n  const TEACHER_ID = TEST_CONFIG.TEACHER_ID\n  const SESSION_ID = TEST_CONFIG.SESSION_ID\n  const DIFFERENT_TEACHER = 'different_teacher_123'\n\n  beforeEach(() => {\n    const mocks = testEnv.getMocks()\n    \n    // Reset all mocks to default state\n    jest.clearAllMocks()\n    \n    // Setup default successful file serving\n    mocks.fileSystem.existsSync.mockReturnValue(true)\n    mocks.fileSystem.fs.stat.mockResolvedValue({\n      size: 1024,\n      mtime: new Date('2024-01-01T12:00:00Z'),\n      birthtime: new Date('2024-01-01T11:00:00Z'),\n      isFile: () => true\n    })\n    mocks.fileSystem.fs.readFile.mockResolvedValue(Buffer.from('test file content'))\n    \n    // Setup default database responses\n    mocks.database.query.mockResolvedValue({ file_uploads: [] })\n    mocks.database.transact.mockResolvedValue({})\n  })\n\n  describe('Successful File Access Analytics', () => {\n    it('should log analytics for authenticated file access with session', async () => {\n      const mocks = testEnv.getMocks()\n      \n      // Mock file record exists and belongs to teacher\n      const fileRecord = testData.createFileRecord({\n        id: 'analytics-test-file',\n        filename: 'analytics-test.txt',\n        teacher_id: TEACHER_ID,\n        file_path: '2024/01/analytics-test.txt'\n      })\n      \n      mocks.database.query.mockResolvedValue({\n        file_uploads: [fileRecord]\n      })\n\n      const request = new NextRequest(\n        `http://localhost:3000/api/files/2024/01/analytics-test.txt?teacherId=${TEACHER_ID}&sessionId=${SESSION_ID}`\n      )\n\n      const response = await GET(request, { params: { path: ['2024', '01', 'analytics-test.txt'] } })\n\n      expect(response.status).toBe(200)\n\n      // Verify analytics logging\n      expect(mocks.database.transact).toHaveBeenCalledWith([\n        expect.objectContaining({\n          'usage_analytics': expect.objectContaining({\n            update: expect.objectContaining({\n              teacher_id: TEACHER_ID,\n              event_type: 'file_access',\n              timestamp: expect.any(Number),\n              session_id: SESSION_ID,\n              feature_used: 'file_serving',\n              duration_ms: expect.any(Number),\n              metadata: expect.objectContaining({\n                file_id: 'analytics-test-file',\n                filename: 'analytics-test.txt',\n                file_path: '2024/01/analytics-test.txt',\n                served_from: 'local',\n                file_size: 1024,\n                is_thumbnail: false,\n                response_time_ms: expect.any(Number)\n              })\n            })\n          })\n        })\n      ])\n    })\n\n    it('should log analytics for authenticated file access without session', async () => {\n      const mocks = testEnv.getMocks()\n      \n      const fileRecord = testData.createFileRecord({\n        id: 'no-session-file',\n        filename: 'no-session.txt',\n        teacher_id: TEACHER_ID\n      })\n      \n      mocks.database.query.mockResolvedValue({\n        file_uploads: [fileRecord]\n      })\n\n      const request = new NextRequest(\n        `http://localhost:3000/api/files/2024/01/no-session.txt?teacherId=${TEACHER_ID}`\n      )\n\n      const response = await GET(request, { params: { path: ['2024', '01', 'no-session.txt'] } })\n\n      expect(response.status).toBe(200)\n\n      // Verify analytics logging without session_id\n      expect(mocks.database.transact).toHaveBeenCalledWith([\n        expect.objectContaining({\n          'usage_analytics': expect.objectContaining({\n            update: expect.objectContaining({\n              teacher_id: TEACHER_ID,\n              event_type: 'file_access',\n              session_id: undefined,\n              metadata: expect.objectContaining({\n                file_id: 'no-session-file'\n              })\n            })\n          })\n        })\n      ])\n    })\n\n    it('should log analytics for thumbnail access', async () => {\n      const mocks = testEnv.getMocks()\n      \n      const fileRecord = testData.createFileRecord({\n        id: 'thumbnail-file',\n        filename: 'image_thumb.jpg',\n        teacher_id: TEACHER_ID\n      })\n      \n      mocks.database.query.mockResolvedValue({\n        file_uploads: [fileRecord]\n      })\n\n      const request = new NextRequest(\n        `http://localhost:3000/api/files/thumbnails/2024/01/image.jpg?teacherId=${TEACHER_ID}`\n      )\n\n      const response = await GET(request, { params: { path: ['thumbnails', '2024', '01', 'image.jpg'] } })\n\n      expect(response.status).toBe(200)\n\n      // Verify thumbnail analytics\n      expect(mocks.database.transact).toHaveBeenCalledWith([\n        expect.objectContaining({\n          'usage_analytics': expect.objectContaining({\n            update: expect.objectContaining({\n              metadata: expect.objectContaining({\n                is_thumbnail: true,\n                file_path: 'thumbnails/2024/01/image.jpg'\n              })\n            })\n          })\n        })\n      ])\n    })\n\n    it('should log analytics for S3-served files', async () => {\n      const mocks = testEnv.getMocks()\n      \n      // Configure S3 environment\n      process.env.AWS_ACCESS_KEY_ID = 'test-key'\n      process.env.AWS_SECRET_ACCESS_KEY = 'test-secret'\n      process.env.AWS_S3_BUCKET_NAME = 'test-bucket'\n\n      // Mock local file not found (force S3 fallback)\n      mocks.fileSystem.existsSync.mockReturnValue(false)\n      mocks.fileSystem.fs.stat.mockRejectedValue(new Error('ENOENT'))\n\n      // Mock S3 operations\n      mocks.s3Client.mockSend.mockResolvedValue({\n        ContentLength: 2048,\n        LastModified: new Date('2024-01-01T12:00:00Z')\n      })\n      \n      mocks.s3Presigner.getSignedUrl.mockResolvedValue('https://test-s3-url.com')\n\n      // Mock successful S3 fetch\n      global.fetch = jest.fn().mockResolvedValue({\n        ok: true,\n        arrayBuffer: () => Promise.resolve(Buffer.from('s3 file content').buffer)\n      }) as jest.MockedFunction<typeof fetch>\n\n      const fileRecord = testData.createFileRecord({\n        id: 's3-file',\n        filename: 's3-test.txt',\n        teacher_id: TEACHER_ID,\n        storage_type: 's3'\n      })\n      \n      mocks.database.query.mockResolvedValue({\n        file_uploads: [fileRecord]\n      })\n\n      const request = new NextRequest(\n        `http://localhost:3000/api/files/2024/01/s3-test.txt?teacherId=${TEACHER_ID}`\n      )\n\n      const response = await GET(request, { params: { path: ['2024', '01', 's3-test.txt'] } })\n\n      expect(response.status).toBe(200)\n\n      // Verify S3 analytics\n      expect(mocks.database.transact).toHaveBeenCalledWith([\n        expect.objectContaining({\n          'usage_analytics': expect.objectContaining({\n            update: expect.objectContaining({\n              metadata: expect.objectContaining({\n                served_from: 's3',\n                file_size: 15 // 's3 file content'.length\n              })\n            })\n          })\n        })\n      ])\n\n      delete (global as any).fetch\n    })\n  })\n\n  describe('Failed File Access Analytics', () => {\n    it('should log analytics for file not found errors', async () => {\n      const mocks = testEnv.getMocks()\n      \n      // Mock file not found\n      mocks.fileSystem.existsSync.mockReturnValue(false)\n      mocks.fileSystem.fs.stat.mockRejectedValue(new Error('ENOENT: file not found'))\n\n      const request = new NextRequest(\n        `http://localhost:3000/api/files/2024/01/missing.txt?teacherId=${TEACHER_ID}`\n      )\n\n      const response = await GET(request, { params: { path: ['2024', '01', 'missing.txt'] } })\n\n      expect(response.status).toBe(404)\n\n      // Verify failed access analytics\n      expect(mocks.database.transact).toHaveBeenCalledWith([\n        expect.objectContaining({\n          'usage_analytics': expect.objectContaining({\n            update: expect.objectContaining({\n              teacher_id: TEACHER_ID,\n              event_type: 'file_access_failed',\n              metadata: expect.objectContaining({\n                file_path: '2024/01/missing.txt',\n                error_message: expect.stringContaining('not found')\n              })\n            })\n          })\n        })\n      ])\n    })\n\n    it('should log analytics for permission denied errors', async () => {\n      const mocks = testEnv.getMocks()\n      \n      // Mock permission denied\n      mocks.fileSystem.fs.stat.mockRejectedValue(\n        Object.assign(new Error('EACCES: permission denied'), { code: 'EACCES' })\n      )\n\n      const request = new NextRequest(\n        `http://localhost:3000/api/files/2024/01/restricted.txt?teacherId=${TEACHER_ID}`\n      )\n\n      const response = await GET(request, { params: { path: ['2024', '01', 'restricted.txt'] } })\n\n      expect(response.status).toBe(500)\n\n      // Verify error analytics\n      expect(mocks.database.transact).toHaveBeenCalledWith([\n        expect.objectContaining({\n          'usage_analytics': expect.objectContaining({\n            update: expect.objectContaining({\n              event_type: 'file_access_failed',\n              metadata: expect.objectContaining({\n                error_message: expect.stringContaining('Path is not a file')\n              })\n            })\n          })\n        })\n      ])\n    })\n\n    it('should log analytics for unauthorized access attempts', async () => {\n      const mocks = testEnv.getMocks()\n      \n      // Mock file owned by different teacher\n      const fileRecord = testData.createFileRecord({\n        teacher_id: DIFFERENT_TEACHER,\n        filename: 'private.txt'\n      })\n      \n      mocks.database.query.mockResolvedValue({\n        file_uploads: [fileRecord]\n      })\n\n      const request = new NextRequest(\n        `http://localhost:3000/api/files/2024/01/private.txt?teacherId=${TEACHER_ID}`\n      )\n\n      const response = await GET(request, { params: { path: ['2024', '01', 'private.txt'] } })\n\n      expect(response.status).toBe(403)\n\n      // Verify unauthorized access analytics\n      expect(mocks.database.transact).toHaveBeenCalledWith([\n        expect.objectContaining({\n          'usage_analytics': expect.objectContaining({\n            update: expect.objectContaining({\n              teacher_id: TEACHER_ID,\n              event_type: 'file_access_failed',\n              metadata: expect.objectContaining({\n                error_message: 'access denied'\n              })\n            })\n          })\n        })\n      ])\n    })\n  })\n\n  describe('System Error Analytics', () => {\n    it('should log system errors when file serving fails', async () => {\n      const mocks = testEnv.getMocks()\n      \n      // Mock unexpected system error\n      mocks.fileSystem.fs.stat.mockRejectedValue(new Error('Unexpected system error'))\n\n      const request = new NextRequest(\n        `http://localhost:3000/api/files/2024/01/system-error.txt?teacherId=${TEACHER_ID}`\n      )\n\n      const response = await GET(request, { params: { path: ['2024', '01', 'system-error.txt'] } })\n\n      expect(response.status).toBe(500)\n\n      // Verify system error analytics\n      expect(mocks.database.transact).toHaveBeenCalledWith([\n        expect.objectContaining({\n          'usage_analytics': expect.objectContaining({\n            update: expect.objectContaining({\n              event_type: 'file_serving_error',\n              metadata: expect.objectContaining({\n                error_message: 'Unexpected system error'\n              })\n            })\n          })\n        })\n      ])\n    })\n\n    it('should handle analytics logging failures gracefully', async () => {\n      const mocks = testEnv.getMocks()\n      \n      // Mock successful file serving\n      const fileRecord = testData.createFileRecord()\n      mocks.database.query.mockResolvedValue({\n        file_uploads: [fileRecord]\n      })\n\n      // Mock analytics logging failure\n      mocks.database.transact.mockRejectedValue(new Error('Analytics database unavailable'))\n\n      const request = new NextRequest(\n        `http://localhost:3000/api/files/2024/01/test.txt?teacherId=${TEACHER_ID}`\n      )\n\n      const response = await GET(request, { params: { path: ['2024', '01', 'test.txt'] } })\n\n      // File should still be served despite analytics failure\n      expect(response.status).toBe(200)\n\n      const body = await response.arrayBuffer()\n      expect(Buffer.from(body).toString()).toBe('test file content')\n    })\n  })\n\n  describe('Analytics Data Quality', () => {\n    it('should include accurate response times in analytics', async () => {\n      const mocks = testEnv.getMocks()\n      \n      const fileRecord = testData.createFileRecord()\n      mocks.database.query.mockResolvedValue({\n        file_uploads: [fileRecord]\n      })\n\n      // Add delay to file reading to test response time measurement\n      mocks.fileSystem.fs.readFile.mockImplementation(() => \n        new Promise(resolve => {\n          setTimeout(() => resolve(Buffer.from('delayed content')), 100)\n        })\n      )\n\n      const startTime = Date.now()\n      const request = new NextRequest(\n        `http://localhost:3000/api/files/2024/01/test.txt?teacherId=${TEACHER_ID}`\n      )\n\n      const response = await GET(request, { params: { path: ['2024', '01', 'test.txt'] } })\n      const actualResponseTime = Date.now() - startTime\n\n      expect(response.status).toBe(200)\n\n      // Verify response time is reasonably accurate\n      expect(mocks.database.transact).toHaveBeenCalledWith([\n        expect.objectContaining({\n          'usage_analytics': expect.objectContaining({\n            update: expect.objectContaining({\n              duration_ms: expect.any(Number),\n              metadata: expect.objectContaining({\n                response_time_ms: expect.any(Number)\n              })\n            })\n          })\n        })\n      ])\n\n      // Extract the logged response time\n      const analyticsCall = mocks.database.transact.mock.calls[0][0][0]\n      const loggedResponseTime = analyticsCall['usage_analytics'][Object.keys(analyticsCall['usage_analytics'])[0]].update.metadata.response_time_ms\n      \n      // Logged time should be reasonably close to actual time (within 50ms tolerance)\n      expect(Math.abs(loggedResponseTime - actualResponseTime)).toBeLessThan(50)\n      expect(loggedResponseTime).toBeGreaterThan(90) // Should reflect the 100ms delay\n    })\n\n    it('should include accurate file sizes in analytics', async () => {\n      const mocks = testEnv.getMocks()\n      \n      const testFileSize = 2048\n      const testContent = 'x'.repeat(testFileSize)\n      \n      mocks.fileSystem.fs.stat.mockResolvedValue({\n        size: testFileSize,\n        mtime: new Date(),\n        birthtime: new Date(),\n        isFile: () => true\n      })\n      \n      mocks.fileSystem.fs.readFile.mockResolvedValue(Buffer.from(testContent))\n      \n      const fileRecord = testData.createFileRecord({\n        file_size: testFileSize\n      })\n      \n      mocks.database.query.mockResolvedValue({\n        file_uploads: [fileRecord]\n      })\n\n      const request = new NextRequest(\n        `http://localhost:3000/api/files/2024/01/test.txt?teacherId=${TEACHER_ID}`\n      )\n\n      const response = await GET(request, { params: { path: ['2024', '01', 'test.txt'] } })\n\n      expect(response.status).toBe(200)\n      expect(response.headers.get('content-length')).toBe(testFileSize.toString())\n\n      // Verify accurate file size logging\n      expect(mocks.database.transact).toHaveBeenCalledWith([\n        expect.objectContaining({\n          'usage_analytics': expect.objectContaining({\n            update: expect.objectContaining({\n              metadata: expect.objectContaining({\n                file_size: testFileSize\n              })\n            })\n          })\n        })\n      ])\n    })\n\n    it('should not log analytics for unauthenticated requests', async () => {\n      const mocks = testEnv.getMocks()\n      \n      // Request without teacherId parameter\n      const request = new NextRequest('http://localhost:3000/api/files/2024/01/public.txt')\n\n      const response = await GET(request, { params: { path: ['2024', '01', 'public.txt'] } })\n\n      expect(response.status).toBe(200)\n\n      // Verify no analytics logging\n      expect(mocks.database.transact).not.toHaveBeenCalled()\n    })\n\n    it('should handle special characters in filenames for analytics', async () => {\n      const mocks = testEnv.getMocks()\n      \n      const unicodeFilename = 'тест файл 📄.txt'\n      const fileRecord = testData.createFileRecord({\n        filename: unicodeFilename,\n        file_path: `2024/01/${unicodeFilename}`\n      })\n      \n      mocks.database.query.mockResolvedValue({\n        file_uploads: [fileRecord]\n      })\n\n      const encodedFilename = encodeURIComponent(unicodeFilename)\n      const request = new NextRequest(\n        `http://localhost:3000/api/files/2024/01/${encodedFilename}?teacherId=${TEACHER_ID}`\n      )\n\n      const response = await GET(request, { params: { path: ['2024', '01', unicodeFilename] } })\n\n      expect(response.status).toBe(200)\n\n      // Verify unicode filename is properly logged\n      expect(mocks.database.transact).toHaveBeenCalledWith([\n        expect.objectContaining({\n          'usage_analytics': expect.objectContaining({\n            update: expect.objectContaining({\n              metadata: expect.objectContaining({\n                filename: unicodeFilename,\n                file_path: `2024/01/${unicodeFilename}`\n              })\n            })\n          })\n        })\n      ])\n    })\n  })\n\n  describe('Analytics Performance Impact', () => {\n    it('should not significantly impact response time', async () => {\n      const mocks = testEnv.getMocks()\n      \n      const fileRecord = testData.createFileRecord()\n      mocks.database.query.mockResolvedValue({\n        file_uploads: [fileRecord]\n      })\n\n      // Test without analytics (no teacherId)\n      const startTimeNoAnalytics = Date.now()\n      const requestNoAnalytics = new NextRequest('http://localhost:3000/api/files/2024/01/test.txt')\n      const responseNoAnalytics = await GET(requestNoAnalytics, { params: { path: ['2024', '01', 'test.txt'] } })\n      const timeNoAnalytics = Date.now() - startTimeNoAnalytics\n\n      expect(responseNoAnalytics.status).toBe(200)\n\n      // Clear mocks\n      jest.clearAllMocks()\n      mocks.database.query.mockResolvedValue({ file_uploads: [fileRecord] })\n\n      // Test with analytics\n      const startTimeWithAnalytics = Date.now()\n      const requestWithAnalytics = new NextRequest(\n        `http://localhost:3000/api/files/2024/01/test.txt?teacherId=${TEACHER_ID}`\n      )\n      const responseWithAnalytics = await GET(requestWithAnalytics, { params: { path: ['2024', '01', 'test.txt'] } })\n      const timeWithAnalytics = Date.now() - startTimeWithAnalytics\n\n      expect(responseWithAnalytics.status).toBe(200)\n      expect(mocks.database.transact).toHaveBeenCalled()\n\n      // Analytics should not add significant overhead\n      const overhead = timeWithAnalytics - timeNoAnalytics\n      expect(Math.abs(overhead)).toBeLessThan(200) // Allow reasonable variance\n\n      console.log(`Analytics overhead: ${overhead}ms`)\n    })\n  })\n})"