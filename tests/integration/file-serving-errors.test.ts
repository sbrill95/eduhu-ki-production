/**
 * Error handling and edge case tests for file serving functionality
 * Tests various failure scenarios and recovery mechanisms
 */

import { createMocks } from 'node-mocks-http'
import { GET, HEAD } from '@/app/api/files/[...path]/route'
import { NextRequest } from 'next/server'
import fs from 'fs/promises'
import path from 'path'

// Mock dependencies with different failure modes
jest.mock('@/lib/instant', () => ({
  db: {
    query: jest.fn(),
    transact: jest.fn()
  },
  FILE_UPLOAD_CONFIG: {
    MAX_FILE_SIZE_MB: 10,
    ALLOWED_TYPES: ['text/plain', 'image/*', 'application/pdf']
  }
}))

jest.mock('@/lib/database', () => ({
  validateSessionAccess: jest.fn()
}))

jest.mock('fs/promises')
jest.mock('fs', () => ({
  existsSync: jest.fn()
}))

jest.mock('@aws-sdk/client-s3')
jest.mock('@aws-sdk/s3-request-presigner')

const mockFs = fs as jest.Mocked<typeof fs>
const mockExistsSync = require('fs').existsSync as jest.MockedFunction<typeof import('fs').existsSync>

describe('File Serving Error Handling Tests', () => {\n  const TEST_TEACHER_ID = 'error_test_teacher'\n  const TEST_SESSION_ID = 'error_test_session'\n\n  beforeEach(() => {\n    jest.clearAllMocks()\n\n    // Reset to default successful mocks\n    const mockDb = require('@/lib/instant').db\n    mockDb.query.mockResolvedValue({ file_uploads: [] })\n    mockDb.transact.mockResolvedValue({})\n\n    const mockValidateSessionAccess = require('@/lib/database').validateSessionAccess\n    mockValidateSessionAccess.mockResolvedValue(true)\n\n    // Clear environment variables\n    delete process.env.AWS_ACCESS_KEY_ID\n    delete process.env.AWS_SECRET_ACCESS_KEY\n    delete process.env.AWS_S3_BUCKET_NAME\n  })\n\n  describe('File System Error Handling', () => {\n    it('should handle ENOENT (file not found) gracefully', async () => {\n      const enoentError = Object.assign(new Error('ENOENT: no such file or directory'), { code: 'ENOENT' })\n      mockFs.stat.mockRejectedValue(enoentError)\n      \n      const request = new NextRequest('http://localhost:3000/api/files/2024/01/missing.txt')\n      const response = await GET(request, { params: { path: ['2024', '01', 'missing.txt'] } })\n\n      expect(response.status).toBe(404)\n\n      const body = await response.json()\n      expect(body.error).toBe('File not found')\n      expect(body.error).not.toContain('ENOENT') // Should not expose internal error codes\n    })\n\n    it('should handle EACCES (permission denied) gracefully', async () => {\n      const eaccesError = Object.assign(new Error('EACCES: permission denied'), { code: 'EACCES' })\n      mockFs.stat.mockRejectedValue(eaccesError)\n      \n      const request = new NextRequest('http://localhost:3000/api/files/2024/01/restricted.txt')\n      const response = await GET(request, { params: { path: ['2024', '01', 'restricted.txt'] } })\n\n      expect(response.status).toBe(500)\n\n      const body = await response.json()\n      expect(body.error).toBe('File access failed')\n      expect(body.error).not.toContain('EACCES')\n    })\n\n    it('should handle EMFILE (too many open files) gracefully', async () => {\n      const emfileError = Object.assign(new Error('EMFILE: too many open files'), { code: 'EMFILE' })\n      mockFs.stat.mockRejectedValue(emfileError)\n      \n      const request = new NextRequest('http://localhost:3000/api/files/2024/01/test.txt')\n      const response = await GET(request, { params: { path: ['2024', '01', 'test.txt'] } })\n\n      expect(response.status).toBe(500)\n\n      const body = await response.json()\n      expect(body.error).toBe('File access failed')\n    })\n\n    it('should handle file read errors after successful stat', async () => {\n      mockFs.stat.mockResolvedValue({\n        size: 100,\n        mtime: new Date(),\n        birthtime: new Date(),\n        isFile: () => true\n      } as any)\n\n      // File exists but read fails\n      mockFs.readFile.mockRejectedValue(new Error('I/O error'))\n\n      const request = new NextRequest('http://localhost:3000/api/files/2024/01/corrupted.txt')\n      const response = await GET(request, { params: { path: ['2024', '01', 'corrupted.txt'] } })\n\n      expect(response.status).toBe(500)\n\n      const body = await response.json()\n      expect(body.error).toBe('File access failed')\n    })\n\n    it('should handle directory instead of file', async () => {\n      mockFs.stat.mockResolvedValue({\n        size: 0,\n        mtime: new Date(),\n        birthtime: new Date(),\n        isFile: () => false // This is a directory\n      } as any)\n\n      const request = new NextRequest('http://localhost:3000/api/files/2024/01/directory')\n      const response = await GET(request, { params: { path: ['2024', '01', 'directory'] } })\n\n      expect(response.status).toBe(500)\n\n      const body = await response.json()\n      expect(body.error).toBe('File access failed')\n    })\n\n    it('should handle file size changes between stat and read', async () => {\n      // Mock stat showing one size\n      mockFs.stat.mockResolvedValue({\n        size: 1000,\n        mtime: new Date(),\n        birthtime: new Date(),\n        isFile: () => true\n      } as any)\n\n      // But readFile returns different content (file was modified)\n      const actualContent = 'much smaller content'\n      mockFs.readFile.mockResolvedValue(Buffer.from(actualContent))\n\n      const request = new NextRequest('http://localhost:3000/api/files/2024/01/modified.txt')\n      const response = await GET(request, { params: { path: ['2024', '01', 'modified.txt'] } })\n\n      expect(response.status).toBe(200)\n      \n      // Should serve the actual content\n      const body = await response.arrayBuffer()\n      expect(Buffer.from(body).toString()).toBe(actualContent)\n    })\n  })\n\n  describe('Database Error Handling', () => {\n    it('should continue serving files when database query fails', async () => {\n      const mockDb = require('@/lib/instant').db\n      mockDb.query.mockRejectedValue(new Error('Database connection failed'))\n\n      // Mock successful file access\n      mockExistsSync.mockReturnValue(true)\n      mockFs.stat.mockResolvedValue({\n        size: 100,\n        mtime: new Date(),\n        birthtime: new Date(),\n        isFile: () => true\n      } as any)\n      mockFs.readFile.mockResolvedValue(Buffer.from('file content'))\n\n      const request = new NextRequest('http://localhost:3000/api/files/2024/01/test.txt')\n      const response = await GET(request, { params: { path: ['2024', '01', 'test.txt'] } })\n\n      // File should still be served despite database error\n      expect(response.status).toBe(200)\n\n      const body = await response.arrayBuffer()\n      expect(Buffer.from(body).toString()).toBe('file content')\n    })\n\n    it('should handle database timeout during file ownership check', async () => {\n      const mockDb = require('@/lib/instant').db\n      const timeoutError = new Error('Query timeout')\n      timeoutError.name = 'TimeoutError'\n      mockDb.query.mockRejectedValue(timeoutError)\n\n      mockExistsSync.mockReturnValue(true)\n      mockFs.stat.mockResolvedValue({\n        size: 50,\n        mtime: new Date(),\n        birthtime: new Date(),\n        isFile: () => true\n      } as any)\n      mockFs.readFile.mockResolvedValue(Buffer.from('content'))\n\n      const request = new NextRequest('http://localhost:3000/api/files/2024/01/test.txt')\n      const response = await GET(request, { params: { path: ['2024', '01', 'test.txt'] } })\n\n      expect(response.status).toBe(200)\n    })\n\n    it('should handle session validation database errors', async () => {\n      const mockValidateSessionAccess = require('@/lib/database').validateSessionAccess\n      mockValidateSessionAccess.mockRejectedValue(new Error('Session validation failed'))\n\n      mockExistsSync.mockReturnValue(true)\n      mockFs.stat.mockResolvedValue({\n        size: 50,\n        mtime: new Date(),\n        birthtime: new Date(),\n        isFile: () => true\n      } as any)\n      mockFs.readFile.mockResolvedValue(Buffer.from('content'))\n\n      const request = new NextRequest(\n        `http://localhost:3000/api/files/2024/01/test.txt?teacherId=${TEST_TEACHER_ID}&sessionId=${TEST_SESSION_ID}`\n      )\n      const response = await GET(request, { params: { path: ['2024', '01', 'test.txt'] } })\n\n      // Should treat validation failure as access denied\n      expect(response.status).toBe(500)\n    })\n\n    it('should handle analytics logging failures gracefully', async () => {\n      const mockDb = require('@/lib/instant').db\n      mockDb.query.mockResolvedValue({\n        file_uploads: [{\n          id: 'file123',\n          filename: 'test.txt',\n          teacher_id: TEST_TEACHER_ID,\n          file_path: '2024/01/test.txt'\n        }]\n      })\n      \n      // Analytics logging fails\n      mockDb.transact.mockRejectedValue(new Error('Analytics database unavailable'))\n\n      mockExistsSync.mockReturnValue(true)\n      mockFs.stat.mockResolvedValue({\n        size: 100,\n        mtime: new Date(),\n        birthtime: new Date(),\n        isFile: () => true\n      } as any)\n      mockFs.readFile.mockResolvedValue(Buffer.from('logged content'))\n\n      const request = new NextRequest(\n        `http://localhost:3000/api/files/2024/01/test.txt?teacherId=${TEST_TEACHER_ID}`\n      )\n      const response = await GET(request, { params: { path: ['2024', '01', 'test.txt'] } })\n\n      // File should still be served despite analytics failure\n      expect(response.status).toBe(200)\n\n      const body = await response.arrayBuffer()\n      expect(Buffer.from(body).toString()).toBe('logged content')\n    })\n  })\n\n  describe('S3 Error Handling', () => {\n    beforeEach(() => {\n      // Configure S3 environment\n      process.env.AWS_ACCESS_KEY_ID = 'test-key'\n      process.env.AWS_SECRET_ACCESS_KEY = 'test-secret'\n      process.env.AWS_S3_BUCKET_NAME = 'test-bucket'\n\n      // Mock local file not found (force S3 fallback)\n      mockExistsSync.mockReturnValue(false)\n      mockFs.stat.mockRejectedValue(new Error('ENOENT'))\n    })\n\n    it('should handle S3 access denied errors', async () => {\n      const mockGetSignedUrl = require('@aws-sdk/s3-request-presigner').getSignedUrl\n      mockGetSignedUrl.mockRejectedValue(new Error('Access Denied'))\n\n      const request = new NextRequest('http://localhost:3000/api/files/2024/01/s3-denied.txt')\n      const response = await GET(request, { params: { path: ['2024', '01', 's3-denied.txt'] } })\n\n      expect(response.status).toBe(404)\n\n      const body = await response.json()\n      expect(body.error).toBe('File not found')\n    })\n\n    it('should handle S3 network timeouts', async () => {\n      const mockGetSignedUrl = require('@aws-sdk/s3-request-presigner').getSignedUrl\n      mockGetSignedUrl.mockResolvedValue('https://test-bucket.s3.amazonaws.com/signed-url')\n\n      // Mock network timeout during S3 fetch\n      global.fetch = jest.fn().mockRejectedValue(new Error('Network timeout')) as jest.MockedFunction<typeof fetch>\n\n      const request = new NextRequest('http://localhost:3000/api/files/2024/01/s3-timeout.txt')\n      const response = await GET(request, { params: { path: ['2024', '01', 's3-timeout.txt'] } })\n\n      expect(response.status).toBe(404)\n\n      delete (global as any).fetch\n    })\n\n    it('should handle S3 service unavailable', async () => {\n      const mockS3Send = jest.fn()\n      mockS3Send.mockRejectedValue(new Error('Service Unavailable'))\n\n      require('@aws-sdk/client-s3').S3Client.mockImplementation(() => ({\n        send: mockS3Send\n      }))\n\n      const mockGetSignedUrl = require('@aws-sdk/s3-request-presigner').getSignedUrl\n      mockGetSignedUrl.mockRejectedValue(new Error('Service Unavailable'))\n\n      const request = new NextRequest('http://localhost:3000/api/files/2024/01/s3-unavailable.txt')\n      const response = await GET(request, { params: { path: ['2024', '01', 's3-unavailable.txt'] } })\n\n      expect(response.status).toBe(404)\n    })\n\n    it('should handle partial S3 responses', async () => {\n      const mockGetSignedUrl = require('@aws-sdk/s3-request-presigner').getSignedUrl\n      mockGetSignedUrl.mockResolvedValue('https://test-bucket.s3.amazonaws.com/signed-url')\n\n      // Mock partial response from S3\n      global.fetch = jest.fn().mockResolvedValue({\n        ok: true,\n        arrayBuffer: () => {\n          // Simulate connection interruption\n          throw new Error('Connection interrupted')\n        }\n      }) as jest.MockedFunction<typeof fetch>\n\n      const request = new NextRequest('http://localhost:3000/api/files/2024/01/s3-partial.txt')\n      const response = await GET(request, { params: { path: ['2024', '01', 's3-partial.txt'] } })\n\n      expect(response.status).toBe(500)\n\n      delete (global as any).fetch\n    })\n\n    it('should handle corrupted S3 responses', async () => {\n      const mockGetSignedUrl = require('@aws-sdk/s3-request-presigner').getSignedUrl\n      mockGetSignedUrl.mockResolvedValue('https://test-bucket.s3.amazonaws.com/signed-url')\n\n      // Mock S3 returning HTTP 200 but with error content\n      global.fetch = jest.fn().mockResolvedValue({\n        ok: false,\n        status: 500,\n        statusText: 'Internal Server Error'\n      }) as jest.MockedFunction<typeof fetch>\n\n      const request = new NextRequest('http://localhost:3000/api/files/2024/01/s3-error.txt')\n      const response = await GET(request, { params: { path: ['2024', '01', 's3-error.txt'] } })\n\n      expect(response.status).toBe(500)\n\n      delete (global as any).fetch\n    })\n  })\n\n  describe('Edge Cases and Boundary Conditions', () => {\n    it('should handle extremely large file paths', async () => {\n      const longPath = Array(100).fill('very-long-segment').join('/')\n      const request = new NextRequest(`http://localhost:3000/api/files/${longPath}`)\n      \n      const pathSegments = longPath.split('/')\n      const response = await GET(request, { params: { path: pathSegments } })\n\n      // Should handle gracefully, likely return 404\n      expect([400, 404]).toContain(response.status)\n    })\n\n    it('should handle empty file names', async () => {\n      const request = new NextRequest('http://localhost:3000/api/files/2024/01/')\n      const response = await GET(request, { params: { path: ['2024', '01', ''] } })\n\n      expect([400, 404]).toContain(response.status)\n    })\n\n    it('should handle files with zero size', async () => {\n      mockExistsSync.mockReturnValue(true)\n      mockFs.stat.mockResolvedValue({\n        size: 0,\n        mtime: new Date(),\n        birthtime: new Date(),\n        isFile: () => true\n      } as any)\n      mockFs.readFile.mockResolvedValue(Buffer.alloc(0))\n\n      const request = new NextRequest('http://localhost:3000/api/files/2024/01/empty.txt')\n      const response = await GET(request, { params: { path: ['2024', '01', 'empty.txt'] } })\n\n      expect(response.status).toBe(200)\n      expect(response.headers.get('content-length')).toBe('0')\n\n      const body = await response.arrayBuffer()\n      expect(body.byteLength).toBe(0)\n    })\n\n    it('should handle files with special unicode characters', async () => {\n      const unicodeFilename = 'файл-тест-📄.txt'\n      \n      mockExistsSync.mockReturnValue(true)\n      mockFs.stat.mockResolvedValue({\n        size: 20,\n        mtime: new Date(),\n        birthtime: new Date(),\n        isFile: () => true\n      } as any)\n      mockFs.readFile.mockResolvedValue(Buffer.from('unicode content'))\n\n      const encodedFilename = encodeURIComponent(unicodeFilename)\n      const request = new NextRequest(`http://localhost:3000/api/files/2024/01/${encodedFilename}`)\n      const response = await GET(request, { params: { path: ['2024', '01', unicodeFilename] } })\n\n      expect(response.status).toBe(200)\n    })\n\n    it('should handle concurrent errors gracefully', async () => {\n      // Simulate race condition where file is deleted between requests\n      let callCount = 0\n      mockFs.stat.mockImplementation(() => {\n        callCount++\n        if (callCount === 1) {\n          return Promise.resolve({\n            size: 100,\n            mtime: new Date(),\n            birthtime: new Date(),\n            isFile: () => true\n          })\n        } else {\n          return Promise.reject(Object.assign(new Error('ENOENT'), { code: 'ENOENT' }))\n        }\n      })\n\n      mockFs.readFile.mockRejectedValue(Object.assign(new Error('ENOENT'), { code: 'ENOENT' }))\n\n      const request1 = new NextRequest('http://localhost:3000/api/files/2024/01/race.txt')\n      const request2 = new NextRequest('http://localhost:3000/api/files/2024/01/race.txt')\n\n      const [response1, response2] = await Promise.all([\n        GET(request1, { params: { path: ['2024', '01', 'race.txt'] } }),\n        GET(request2, { params: { path: ['2024', '01', 'race.txt'] } })\n      ])\n\n      // At least one should handle the race condition gracefully\n      expect([200, 404, 500]).toContain(response1.status)\n      expect([200, 404, 500]).toContain(response2.status)\n    })\n  })\n\n  describe('Resource Exhaustion Scenarios', () => {\n    it('should handle memory pressure during large file operations', async () => {\n      // Simulate large file\n      const largeSize = 10 * 1024 * 1024 // 10MB\n      \n      mockExistsSync.mockReturnValue(true)\n      mockFs.stat.mockResolvedValue({\n        size: largeSize,\n        mtime: new Date(),\n        birthtime: new Date(),\n        isFile: () => true\n      } as any)\n\n      // Simulate memory pressure during read\n      mockFs.readFile.mockRejectedValue(new Error('Cannot allocate memory'))\n\n      const request = new NextRequest('http://localhost:3000/api/files/2024/01/huge.txt')\n      const response = await GET(request, { params: { path: ['2024', '01', 'huge.txt'] } })\n\n      expect(response.status).toBe(500)\n\n      const body = await response.json()\n      expect(body.error).toBe('File access failed')\n    })\n\n    it('should handle disk space issues', async () => {\n      const enospcError = Object.assign(new Error('ENOSPC: no space left on device'), { code: 'ENOSPC' })\n      mockFs.stat.mockRejectedValue(enospcError)\n\n      const request = new NextRequest('http://localhost:3000/api/files/2024/01/test.txt')\n      const response = await GET(request, { params: { path: ['2024', '01', 'test.txt'] } })\n\n      expect(response.status).toBe(500)\n    })\n  })\n\n  describe('HEAD Request Error Handling', () => {\n    it('should handle HEAD request errors consistently with GET', async () => {\n      mockFs.stat.mockRejectedValue(Object.assign(new Error('ENOENT'), { code: 'ENOENT' }))\n\n      const headRequest = new NextRequest('http://localhost:3000/api/files/2024/01/missing.txt', { method: 'HEAD' })\n      const getRequest = new NextRequest('http://localhost:3000/api/files/2024/01/missing.txt')\n\n      const [headResponse, getResponse] = await Promise.all([\n        HEAD(headRequest, { params: { path: ['2024', '01', 'missing.txt'] } }),\n        GET(getRequest, { params: { path: ['2024', '01', 'missing.txt'] } })\n      ])\n\n      expect(headResponse.status).toBe(404)\n      expect(getResponse.status).toBe(404)\n\n      // HEAD response should have no body\n      const headBody = await headResponse.text()\n      expect(headBody).toBe('')\n    })\n\n    it('should handle HEAD request timeout scenarios', async () => {\n      // Simulate very slow file system operation\n      mockFs.stat.mockImplementation(() => new Promise((resolve) => {\n        setTimeout(() => {\n          resolve({\n            size: 100,\n            mtime: new Date(),\n            birthtime: new Date(),\n            isFile: () => true\n          } as any)\n        }, 5000) // 5 second delay\n      }))\n\n      const request = new NextRequest('http://localhost:3000/api/files/2024/01/slow.txt', { method: 'HEAD' })\n      \n      // Set a timeout for the test\n      const timeoutPromise = new Promise((_, reject) => {\n        setTimeout(() => reject(new Error('Test timeout')), 1000)\n      })\n\n      try {\n        await Promise.race([\n          HEAD(request, { params: { path: ['2024', '01', 'slow.txt'] } }),\n          timeoutPromise\n        ])\n        \n        // If we reach here, the response was faster than timeout\n        expect(true).toBe(true) // Test passes\n      } catch (error) {\n        // If timeout occurs, that's also acceptable for this test\n        expect(error.message).toBe('Test timeout')\n      }\n    })\n  })\n\n  describe('Recovery and Fallback Scenarios', () => {\n    it('should recover from temporary file system issues', async () => {\n      let attemptCount = 0\n      mockFs.stat.mockImplementation(() => {\n        attemptCount++\n        if (attemptCount === 1) {\n          // First attempt fails\n          return Promise.reject(new Error('Temporary failure'))\n        } else {\n          // Subsequent attempts succeed\n          return Promise.resolve({\n            size: 100,\n            mtime: new Date(),\n            birthtime: new Date(),\n            isFile: () => true\n          } as any)\n        }\n      })\n\n      mockFs.readFile.mockResolvedValue(Buffer.from('recovered content'))\n\n      // Make multiple requests\n      const request1 = new NextRequest('http://localhost:3000/api/files/2024/01/temp-fail.txt')\n      const response1 = await GET(request1, { params: { path: ['2024', '01', 'temp-fail.txt'] } })\n\n      const request2 = new NextRequest('http://localhost:3000/api/files/2024/01/temp-fail.txt')\n      const response2 = await GET(request2, { params: { path: ['2024', '01', 'temp-fail.txt'] } })\n\n      // First request fails, second succeeds\n      expect(response1.status).toBe(500)\n      expect(response2.status).toBe(200)\n    })\n  })\n})"