/**
 * Test environment setup and configuration for file storage tests
 * Provides test database setup, AWS mocking, and environment configuration
 */

import { beforeEach, afterEach, beforeAll, afterAll } from '@jest/globals'\nimport {\n  createMockS3Client,\n  createMockS3Presigner,\n  createMockDatabase,\n  createMockFileSystem,\n  createMockDatabaseValidation,\n  setupTestEnvironment\n} from './test-mocks'\n\n// Global test configuration\nexport const TEST_CONFIG = {\n  BASE_URL: process.env.TEST_BASE_URL || 'http://localhost:3000',\n  TEACHER_ID: 'test_teacher_123',\n  SESSION_ID: 'test_session_456',\n  S3_BUCKET: 'test-bucket',\n  S3_REGION: 'us-east-1',\n  FILE_UPLOAD_CONFIG: {\n    MAX_FILE_SIZE_MB: 10,\n    ALLOWED_TYPES: ['text/plain', 'image/*', 'application/pdf']\n  }\n} as const\n\n// Mock setup for all file storage tests\nexport const setupFileStorageTestEnvironment = () => {\n  let envRestore: () => void\n  let mocks: any = {}\n\n  beforeAll(() => {\n    // Setup environment\n    const env = setupTestEnvironment()\n    envRestore = env.restore\n\n    // Configure default S3 settings for testing\n    env.setS3Config({\n      accessKeyId: 'test-access-key',\n      secretAccessKey: 'test-secret-key',\n      bucketName: TEST_CONFIG.S3_BUCKET,\n      region: TEST_CONFIG.S3_REGION\n    })\n\n    console.log('ðŸ“‹ File storage test environment initialized')\n  })\n\n  beforeEach(() => {\n    // Create fresh mocks for each test\n    mocks = {\n      s3Client: createMockS3Client(),\n      s3Presigner: createMockS3Presigner(),\n      database: createMockDatabase(),\n      fileSystem: createMockFileSystem(),\n      databaseValidation: createMockDatabaseValidation()\n    }\n\n    // Setup default mock behaviors\n    setupDefaultMocks(mocks)\n  })\n\n  afterEach(() => {\n    // Clear all mocks\n    jest.clearAllMocks()\n  })\n\n  afterAll(() => {\n    // Restore environment\n    if (envRestore) {\n      envRestore()\n    }\n\n    console.log('ðŸ§¹ File storage test environment cleaned up')\n  })\n\n  return {\n    getMocks: () => mocks,\n    getConfig: () => TEST_CONFIG\n  }\n}\n\n// Setup default mock behaviors\nconst setupDefaultMocks = (mocks: any) => {\n  // Default database responses\n  mocks.database.query.mockResolvedValue({ file_uploads: [] })\n  mocks.database.transact.mockResolvedValue({})\n\n  // Default file system responses\n  mocks.fileSystem.existsSync.mockReturnValue(true)\n  mocks.fileSystem.fs.stat.mockResolvedValue({\n    size: 1024,\n    mtime: new Date('2024-01-01T12:00:00Z'),\n    birthtime: new Date('2024-01-01T11:00:00Z'),\n    isFile: () => true\n  })\n  mocks.fileSystem.fs.readFile.mockResolvedValue(Buffer.from('test file content'))\n  mocks.fileSystem.fs.writeFile.mockResolvedValue(undefined)\n  mocks.fileSystem.fs.mkdir.mockResolvedValue(undefined)\n  mocks.fileSystem.fs.unlink.mockResolvedValue(undefined)\n\n  // Default S3 responses\n  mocks.s3Client.mockSend.mockResolvedValue({ ETag: '\"test-etag\"' })\n  mocks.s3Presigner.getSignedUrl.mockResolvedValue('https://test-signed-url.com')\n\n  // Default session validation\n  mocks.databaseValidation.validateSessionAccess.mockResolvedValue(true)\n}\n\n// Jest setup for AWS SDK mocking\nexport const setupAWSMocks = () => {\n  jest.mock('@aws-sdk/client-s3', () => {\n    const mocks = createMockS3Client()\n    return {\n      S3Client: mocks.S3Client,\n      PutObjectCommand: mocks.PutObjectCommand,\n      DeleteObjectCommand: mocks.DeleteObjectCommand,\n      HeadObjectCommand: mocks.HeadObjectCommand,\n      GetObjectCommand: mocks.GetObjectCommand\n    }\n  })\n\n  jest.mock('@aws-sdk/s3-request-presigner', () => {\n    const mocks = createMockS3Presigner()\n    return {\n      getSignedUrl: mocks.getSignedUrl\n    }\n  })\n}\n\n// Jest setup for InstantDB mocking\nexport const setupDatabaseMocks = () => {\n  jest.mock('@/lib/instant', () => {\n    const mockDb = createMockDatabase()\n    return {\n      db: mockDb,\n      FILE_UPLOAD_CONFIG: TEST_CONFIG.FILE_UPLOAD_CONFIG\n    }\n  })\n\n  jest.mock('@/lib/database', () => {\n    const mocks = createMockDatabaseValidation()\n    return {\n      validateSessionAccess: mocks.validateSessionAccess\n    }\n  })\n}\n\n// Jest setup for file system mocking\nexport const setupFileSystemMocks = () => {\n  jest.mock('fs/promises', () => {\n    const mocks = createMockFileSystem()\n    return mocks.fs\n  })\n\n  jest.mock('fs', () => {\n    const mocks = createMockFileSystem()\n    return {\n      existsSync: mocks.existsSync\n    }\n  })\n}\n\n// Complete test environment setup\nexport const setupCompleteTestEnvironment = () => {\n  setupAWSMocks()\n  setupDatabaseMocks()\n  setupFileSystemMocks()\n  \n  return setupFileStorageTestEnvironment()\n}\n\n// Test data generators\nexport const generateTestData = () => ({\n  createFileRecord: (overrides: Partial<any> = {}) => ({\n    id: `file_${Date.now()}`,\n    filename: 'test.txt',\n    teacher_id: TEST_CONFIG.TEACHER_ID,\n    file_path: '2024/01/test.txt',\n    created_at: Date.now(),\n    updated_at: Date.now(),\n    file_size: 1024,\n    mime_type: 'text/plain',\n    storage_type: 'local',\n    ...overrides\n  }),\n\n  createUsageAnalytics: (overrides: Partial<any> = {}) => ({\n    id: `analytics_${Date.now()}`,\n    teacher_id: TEST_CONFIG.TEACHER_ID,\n    event_type: 'file_access',\n    timestamp: Date.now(),\n    session_id: TEST_CONFIG.SESSION_ID,\n    feature_used: 'file_serving',\n    duration_ms: 100,\n    metadata: {\n      file_path: '2024/01/test.txt',\n      served_from: 'local',\n      file_size: 1024,\n      response_time_ms: 100\n    },\n    ...overrides\n  }),\n\n  createS3FileInfo: (overrides: Partial<any> = {}) => ({\n    ContentLength: 2048,\n    LastModified: new Date('2024-01-01T12:00:00Z'),\n    Metadata: {\n      originalName: 'test.txt',\n      uploadedAt: '2024-01-01T12:00:00Z',\n      fileSize: '2048'\n    },\n    ...overrides\n  })\n})\n\n// Test assertion helpers\nexport const createTestAssertions = () => ({\n  expectSuccessfulFileResponse: (response: any, expectedSize?: number) => {\n    expect(response.status).toBe(200)\n    expect(response.headers.get('content-type')).toBeTruthy()\n    expect(response.headers.get('cache-control')).toContain('max-age')\n    expect(response.headers.get('x-content-type-options')).toBe('nosniff')\n    expect(response.headers.get('x-frame-options')).toBe('DENY')\n    \n    if (expectedSize !== undefined) {\n      expect(response.headers.get('content-length')).toBe(expectedSize.toString())\n    }\n  },\n\n  expectFileNotFoundResponse: (response: any) => {\n    expect(response.status).toBe(404)\n    expect(response.headers.get('content-type')).toBe('application/json')\n  },\n\n  expectSecurityErrorResponse: (response: any, expectedError: string) => {\n    expect([400, 403]).toContain(response.status)\n    \n    if (response.status >= 400) {\n      const body = response.json ? response.json() : JSON.parse(response.body || '{}')\n      expect(body).toHaveProperty('error')\n      if (expectedError) {\n        expect(body.error).toBe(expectedError)\n      }\n    }\n  },\n\n  expectAnalyticsLogged: (mockTransact: any, eventType: string, teacherId = TEST_CONFIG.TEACHER_ID) => {\n    expect(mockTransact).toHaveBeenCalledWith([\n      expect.objectContaining({\n        'usage_analytics': expect.objectContaining({\n          update: expect.objectContaining({\n            teacher_id: teacherId,\n            event_type: eventType,\n            timestamp: expect.any(Number),\n            feature_used: 'file_serving'\n          })\n        })\n      })\n    ])\n  },\n\n  expectPerformanceWithinThreshold: (responseTime: number, threshold: number, operation: string) => {\n    expect(responseTime).toBeLessThan(threshold)\n    console.log(`âœ… ${operation} completed in ${responseTime}ms (threshold: ${threshold}ms)`)\n  }\n})\n\n// Test scenario builders\nexport const createTestScenarios = () => ({\n  fileServing: {\n    localStorageSuccess: {\n      name: 'successful local file serving',\n      setup: (mocks: any) => {\n        mocks.fileSystem.existsSync.mockReturnValue(true)\n        mocks.fileSystem.fs.stat.mockResolvedValue({\n          size: 1024,\n          mtime: new Date(),\n          birthtime: new Date(),\n          isFile: () => true\n        })\n        mocks.fileSystem.fs.readFile.mockResolvedValue(Buffer.from('local file content'))\n      },\n      expectedHeaders: {\n        'x-served-from': 'local',\n        'content-length': '1024'\n      }\n    },\n\n    s3FallbackSuccess: {\n      name: 'successful S3 fallback',\n      setup: (mocks: any) => {\n        // Local file not found\n        mocks.fileSystem.existsSync.mockReturnValue(false)\n        mocks.fileSystem.fs.stat.mockRejectedValue(new Error('ENOENT'))\n\n        // S3 configured and available\n        process.env.AWS_ACCESS_KEY_ID = 'test-key'\n        process.env.AWS_SECRET_ACCESS_KEY = 'test-secret'\n        process.env.AWS_S3_BUCKET_NAME = 'test-bucket'\n\n        mocks.s3Client.mockSend.mockResolvedValue({\n          ContentLength: 2048,\n          LastModified: new Date()\n        })\n        \n        mocks.s3Presigner.getSignedUrl.mockResolvedValue('https://s3-signed-url.com')\n\n        // Mock successful S3 fetch\n        global.fetch = jest.fn().mockResolvedValue({\n          ok: true,\n          arrayBuffer: () => Promise.resolve(Buffer.from('s3 file content').buffer)\n        })\n      },\n      expectedHeaders: {\n        'x-served-from': 's3'\n      },\n      cleanup: () => {\n        delete (global as any).fetch\n      }\n    }\n  },\n\n  security: {\n    pathTraversal: {\n      name: 'path traversal attempt',\n      paths: [\n        ['..', '..', '..', 'etc', 'passwd'],\n        ['%2e%2e', '%2f%2e%2e', 'etc', 'passwd'],\n        ['~', 'user', '.ssh', 'id_rsa']\n      ],\n      expectedStatus: 400,\n      expectedError: 'Invalid file path'\n    },\n\n    unauthorizedAccess: {\n      name: 'unauthorized file access',\n      setup: (mocks: any, differentTeacherId: string) => {\n        mocks.database.query.mockResolvedValue({\n          file_uploads: [{\n            id: 'protected-file',\n            filename: 'private.txt',\n            teacher_id: differentTeacherId,\n            file_path: '2024/01/private.txt'\n          }]\n        })\n      },\n      expectedStatus: 403,\n      expectedError: 'File access denied'\n    }\n  },\n\n  performance: {\n    smallFile: {\n      name: 'small file performance',\n      fileSize: 1024, // 1KB\n      expectedThreshold: 500 // 500ms\n    },\n\n    largeFile: {\n      name: 'large file performance',\n      fileSize: 5 * 1024 * 1024, // 5MB\n      expectedThreshold: 2000 // 2s\n    },\n\n    concurrentRequests: {\n      name: 'concurrent request handling',\n      concurrency: 10,\n      expectedThreshold: 5000 // 5s total\n    }\n  }\n})\n\n// Cleanup utilities\nexport const createCleanupUtils = () => ({\n  cleanupTestFiles: async (baseDir: string) => {\n    const fs = require('fs/promises')\n    const path = require('path')\n    \n    try {\n      const files = await fs.readdir(baseDir, { recursive: true })\n      for (const file of files) {\n        if (file.startsWith('test-') || file.includes('temp')) {\n          await fs.unlink(path.join(baseDir, file)).catch(() => {})\n        }\n      }\n    } catch (error) {\n      console.warn('Could not cleanup test files:', error)\n    }\n  },\n\n  resetMocks: (mocks: any) => {\n    Object.values(mocks).forEach((mockGroup: any) => {\n      if (typeof mockGroup === 'object') {\n        Object.values(mockGroup).forEach((mockFn: any) => {\n          if (jest.isMockFunction(mockFn)) {\n            mockFn.mockClear()\n          }\n        })\n      }\n    })\n  },\n\n  restoreEnvironment: () => {\n    const envVars = [\n      'AWS_ACCESS_KEY_ID',\n      'AWS_SECRET_ACCESS_KEY',\n      'AWS_S3_BUCKET_NAME',\n      'AWS_S3_REGION',\n      'NEXT_PUBLIC_BASE_URL'\n    ]\n    \n    envVars.forEach(varName => {\n      delete process.env[varName]\n    })\n  }\n})"