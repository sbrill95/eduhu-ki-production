/**
 * Centralized test mocking utilities for file storage testing
 * Provides reusable mocks for AWS S3, database, and file system operations
 */

import { jest } from '@jest/globals'

// Mock AWS S3 Client and operations
export const createMockS3Client = () => {\n  const mockSend = jest.fn()\n  \n  const MockS3Client = jest.fn().mockImplementation(() => ({\n    send: mockSend\n  }))\n\n  return {\n    S3Client: MockS3Client,\n    mockSend,\n    PutObjectCommand: jest.fn(),\n    DeleteObjectCommand: jest.fn(),\n    HeadObjectCommand: jest.fn(),\n    GetObjectCommand: jest.fn()\n  }\n}\n\n// Mock S3 request presigner\nexport const createMockS3Presigner = () => ({\n  getSignedUrl: jest.fn().mockResolvedValue('https://mock-signed-url.com')\n})\n\n// Mock InstantDB database\nexport const createMockDatabase = () => {\n  const mockDb = {\n    query: jest.fn(),\n    transact: jest.fn(),\n    tx: {\n      usage_analytics: {},\n      file_uploads: {}\n    }\n  }\n\n  // Create dynamic transaction structure\n  const createTx = (id: string) => ({\n    update: jest.fn()\n  })\n\n  // Mock transaction proxy\n  const createTxProxy = (entityName: string) => new Proxy({}, {\n    get: (target, prop) => {\n      if (typeof prop === 'string') {\n        return {\n          update: jest.fn()\n        }\n      }\n      return target[prop]\n    }\n  })\n\n  mockDb.tx = new Proxy({}, {\n    get: (target, entityName) => {\n      if (typeof entityName === 'string') {\n        return createTxProxy(entityName)\n      }\n      return target[entityName]\n    }\n  })\n\n  return mockDb\n}\n\n// Mock file system operations\nexport const createMockFileSystem = () => {\n  const mockFs = {\n    writeFile: jest.fn(),\n    readFile: jest.fn(),\n    unlink: jest.fn(),\n    stat: jest.fn(),\n    mkdir: jest.fn()\n  }\n\n  const mockExistsSync = jest.fn()\n\n  return {\n    fs: mockFs,\n    existsSync: mockExistsSync\n  }\n}\n\n// Mock database validation functions\nexport const createMockDatabaseValidation = () => ({\n  validateSessionAccess: jest.fn().mockResolvedValue(true)\n})\n\n// Test data factories\nexport const createMockFile = (name: string, content: string, type = 'text/plain') => {\n  const buffer = Buffer.from(content)\n  return new File([buffer], name, { type })\n}\n\nexport const createMockFileRecord = (overrides: Partial<any> = {}) => ({\n  id: 'mock-file-id',\n  filename: 'test.txt',\n  teacher_id: 'test-teacher',\n  file_path: '2024/01/test.txt',\n  created_at: Date.now(),\n  updated_at: Date.now(),\n  file_size: 1024,\n  mime_type: 'text/plain',\n  ...overrides\n})\n\nexport const createMockFileStats = (overrides: Partial<any> = {}) => ({\n  size: 1024,\n  mtime: new Date('2024-01-01T12:00:00Z'),\n  birthtime: new Date('2024-01-01T11:00:00Z'),\n  isFile: () => true,\n  ...overrides\n})\n\n// Environment setup utilities\nexport const setupTestEnvironment = () => {\n  // Clear all environment variables\n  const envBackup = { ...process.env }\n  \n  delete process.env.AWS_ACCESS_KEY_ID\n  delete process.env.AWS_SECRET_ACCESS_KEY\n  delete process.env.AWS_S3_BUCKET_NAME\n  delete process.env.AWS_S3_REGION\n\n  return {\n    restore: () => {\n      process.env = envBackup\n    },\n    setS3Config: (config: {\n      accessKeyId?: string\n      secretAccessKey?: string\n      bucketName?: string\n      region?: string\n    }) => {\n      if (config.accessKeyId) process.env.AWS_ACCESS_KEY_ID = config.accessKeyId\n      if (config.secretAccessKey) process.env.AWS_SECRET_ACCESS_KEY = config.secretAccessKey\n      if (config.bucketName) process.env.AWS_S3_BUCKET_NAME = config.bucketName\n      if (config.region) process.env.AWS_S3_REGION = config.region\n    }\n  }\n}\n\n// Mock response helpers\nexport const createMockResponse = (status: number, body?: any, headers: Record<string, string> = {}) => {\n  const response = {\n    status,\n    ok: status >= 200 && status < 300,\n    headers: new Map(Object.entries(headers)),\n    json: jest.fn().mockResolvedValue(body),\n    text: jest.fn().mockResolvedValue(typeof body === 'string' ? body : JSON.stringify(body)),\n    arrayBuffer: jest.fn().mockResolvedValue(\n      typeof body === 'string' ? Buffer.from(body).buffer : Buffer.from(JSON.stringify(body || '')).buffer\n    )\n  }\n\n  return response\n}\n\n// Test scenarios for different error conditions\nexport const createErrorScenarios = () => ({\n  fileNotFound: {\n    mockFs: {\n      stat: jest.fn().mockRejectedValue(Object.assign(new Error('ENOENT'), { code: 'ENOENT' }))\n    }\n  },\n  \n  permissionDenied: {\n    mockFs: {\n      stat: jest.fn().mockRejectedValue(Object.assign(new Error('EACCES'), { code: 'EACCES' }))\n    }\n  },\n\n  diskFull: {\n    mockFs: {\n      stat: jest.fn().mockRejectedValue(Object.assign(new Error('ENOSPC'), { code: 'ENOSPC' }))\n    }\n  },\n\n  databaseDown: {\n    mockDb: {\n      query: jest.fn().mockRejectedValue(new Error('Connection failed')),\n      transact: jest.fn().mockRejectedValue(new Error('Connection failed'))\n    }\n  },\n\n  s3AccessDenied: {\n    mockS3: {\n      send: jest.fn().mockRejectedValue(new Error('AccessDenied: Access Denied'))\n    },\n    mockPresigner: {\n      getSignedUrl: jest.fn().mockRejectedValue(new Error('AccessDenied'))\n    }\n  },\n\n  s3ServiceUnavailable: {\n    mockS3: {\n      send: jest.fn().mockRejectedValue(new Error('ServiceUnavailable'))\n    }\n  },\n\n  networkTimeout: {\n    mockFetch: jest.fn().mockRejectedValue(new Error('Network timeout'))\n  }\n})\n\n// Performance test utilities\nexport const createPerformanceTimer = () => {\n  const start = Date.now()\n  \n  return {\n    elapsed: () => Date.now() - start,\n    measure: (label: string) => {\n      const elapsed = Date.now() - start\n      console.log(`Performance [${label}]: ${elapsed}ms`)\n      return elapsed\n    }\n  }\n}\n\n// Concurrency test helpers\nexport const runConcurrentRequests = async <T>(\n  requestFactory: () => Promise<T>,\n  concurrency: number\n): Promise<{ results: T[], totalTime: number, avgTime: number }> => {\n  const startTime = Date.now()\n  \n  const requests = Array.from({ length: concurrency }, requestFactory)\n  const results = await Promise.all(requests)\n  \n  const totalTime = Date.now() - startTime\n  const avgTime = totalTime / concurrency\n  \n  return { results, totalTime, avgTime }\n}\n\n// Memory usage monitoring (mock implementation)\nexport const createMemoryMonitor = () => {\n  const initialUsage = process.memoryUsage()\n  \n  return {\n    getUsage: () => {\n      const current = process.memoryUsage()\n      return {\n        heapUsed: current.heapUsed - initialUsage.heapUsed,\n        heapTotal: current.heapTotal - initialUsage.heapTotal,\n        external: current.external - initialUsage.external,\n        rss: current.rss - initialUsage.rss\n      }\n    },\n    \n    reset: () => {\n      const newInitial = process.memoryUsage()\n      Object.assign(initialUsage, newInitial)\n    }\n  }\n}\n\n// Test file creation utilities\nexport const createTestFiles = async (baseDir: string, files: Array<{ name: string, size: number }>) => {\n  const fs = require('fs/promises')\n  const path = require('path')\n  \n  const createdFiles: string[] = []\n  \n  try {\n    await fs.mkdir(baseDir, { recursive: true })\n    \n    for (const file of files) {\n      const filePath = path.join(baseDir, file.name)\n      const content = 'x'.repeat(file.size)\n      await fs.writeFile(filePath, content)\n      createdFiles.push(filePath)\n    }\n    \n    return {\n      files: createdFiles,\n      cleanup: async () => {\n        for (const filePath of createdFiles) {\n          try {\n            await fs.unlink(filePath)\n          } catch (error) {\n            console.warn(`Could not delete ${filePath}:`, error)\n          }\n        }\n      }\n    }\n  } catch (error) {\n    console.error('Failed to create test files:', error)\n    throw error\n  }\n}\n\n// Security test helpers\nexport const createSecurityTestCases = () => ({\n  pathTraversalAttempts: [\n    ['..', '..', '..', 'etc', 'passwd'],\n    ['%2e%2e', '%2f%2e%2e', '%2f%2e%2e', 'etc', 'passwd'],\n    ['..%2F', '..%5C', 'windows', 'system32'],\n    ['~', 'user', '.ssh', 'id_rsa'],\n    ['/', 'etc', 'passwd'],\n    ['C:', 'windows', 'system32']\n  ],\n  \n  maliciousFilenames: [\n    '../../../etc/passwd',\n    'file\\x00.exe',\n    'file<script>alert(1)</script>',\n    'file\\'; DROP TABLE users; --',\n    'file\\x00\\x01\\x02',\n    'a'.repeat(1000)\n  ],\n  \n  dangerousExtensions: [\n    'malware.exe',\n    'script.bat',\n    'virus.scr',\n    'trojan.com',\n    'malicious.js',\n    'backdoor.vbs',\n    'rootkit.jar'\n  ]\n})\n\n// Analytics test helpers\nexport const createAnalyticsTestHelpers = () => ({\n  expectAnalyticsCall: (mockTransact: any, expectedData: Partial<any>) => {\n    expect(mockTransact).toHaveBeenCalledWith([\n      expect.objectContaining({\n        'usage_analytics': expect.objectContaining({\n          update: expect.objectContaining(expectedData)\n        })\n      })\n    ])\n  },\n  \n  expectNoAnalyticsCall: (mockTransact: any) => {\n    expect(mockTransact).not.toHaveBeenCalled()\n  },\n  \n  createAnalyticsPayload: (overrides: Partial<any> = {}) => ({\n    teacher_id: 'test-teacher',\n    event_type: 'file_access',\n    timestamp: expect.any(Number),\n    feature_used: 'file_serving',\n    duration_ms: expect.any(Number),\n    metadata: expect.objectContaining({\n      file_path: expect.any(String),\n      served_from: expect.stringMatching(/^(local|s3)$/),\n      response_time_ms: expect.any(Number)\n    }),\n    ...overrides\n  })\n})"